<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
arm_length = 384;
arm_width  = 16;
arm_extent = 0;
seg_amount = 5;
seg_amount_max = seg_amount*2;
seg_len = arm_length/seg_amount;
spd = .1;
max_spd = (240/room_speed)*2;
tmo = 8;

target_item = noone;
held_item = noone;

for( var i = 0; i &lt; seg_amount_max; i++) {
    segment[i] = -1;
}

target = noone;
target_x = 0;
target_y = 0;

seg_end = noone;
alarm[0] = 1;

x = room_width/2;
//y = room_height;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
    
for( var i = 0; i &lt; seg_amount; i++) {
    segment[i] = instance_create(x+seg_len*i,y,obj_segment);
    segment[i].parent = id;
    
    segment[i].len   = seg_len;
    segment[i].angle = 0;
    
    if(i &gt; 0) {
        segment[ i ].prev_seg = segment[i-1];
        segment[i-1].next_seg = segment[ i ];
    }
}

target = instance_create(x, y-128, obj_target);
seg_end = segment[seg_amount-1];

seg_end.x++;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Input

if(alarm[0] &lt; 0) {
    arm_extent = (distance_to_point(seg_end.bx, seg_end.by) / arm_length);
    
    if(mouse_check_button_pressed(mb_left)) {
        if(!instance_exists(obj_item))
            instance_create(mouse_x, mouse_y, obj_item);
            
        else {
            var v = 0;
            var insn = instance_number(obj_item);
            for(var i = 0; i &lt; insn; i++) {
                var iitem = instance_find(obj_item, i);
                if(   mouse_x &gt;= iitem.bbox_left  &amp;&amp; 
                      mouse_x &lt;= iitem.bbox_right &amp;&amp;
                      mouse_y &gt;= iitem.bbox_top   &amp;&amp;
                      mouse_y &lt;= iitem.bbox_bottom) {
                          v++;
                }         
            }
            if(v == 0) instance_create(mouse_x, mouse_y, obj_item);
        }
    }
    
    if(mouse_check_button(mb_left)) {
        if(instance_exists(obj_item)) {
            var clos_item = instance_nearest(mouse_x, mouse_y, obj_item);
            clos_item.x = mouse_x;
            clos_item.y = mouse_y;
        }
    }
    
    if(instance_exists(target_item)) { // Collision with item
        var item = target_item.id;
        if( seg_end.bx &gt;= item.x-tmo &amp;&amp; 
            seg_end.bx &lt;= item.x+tmo &amp;&amp;
            seg_end.by &gt;= item.y-tmo &amp;&amp;
            seg_end.by &lt;= item.y+tmo ) {
            
            var nitem = instance_create(0,0,obj_target);
                nitem.sprite_index = item.sprite_index;
                nitem.bxoffset = item.x-seg_end.bx;
                nitem.byoffset = item.y-seg_end.by;
                nitem.x = seg_end.bx;
                nitem.y = seg_end.by;
                nitem.visible = true;
                
            held_item = nitem;
            
            with(item) instance_destroy();
        }
    }
    
    if(instance_exists(held_item)) {
        held_item.x = seg_end.bx;
        held_item.y = seg_end.by;
        
        var dest = obj_collector;
        if(instance_exists(dest)) {
            target.x += clamp((dest.x - target.x)*spd, -max_spd, max_spd);
            target.y += clamp((dest.y - target.y)*spd, -max_spd, max_spd);
            
            if( seg_end.bx &gt; dest.bbox_left  &amp;&amp;
                seg_end.bx &lt; dest.bbox_right &amp;&amp;
                seg_end.by &gt; dest.bbox_top   &amp;&amp;
                seg_end.by &lt; dest.bbox_bottom) { // Collision with destination
                
                /*instance_create(seg_end.bx + held_item.dxoffset,
                                seg_end.by + held_item.dyoffset,
                                obj_item);*/
                dest.ping = true;
                dest.collected++;
                with(held_item) instance_destroy();
                held_item = noone;
                
                // Reward
                arm_length *= 1.003;
                if(seg_amount &lt; seg_amount_max) {
                    //seg_amount++;
                    seg_len = arm_length/seg_amount;
                    max_spd = min(max_spd*1.04, (240/room_speed)*4);
                    /*var i = seg_amount-1;
                    segment[i] = instance_create(x,y,obj_segment);
                    segment[i].parent = id;
                    
                    segment[i].len   = seg_len;
                    segment[i].angle = 0;
                    seg_end = segment[i];
                    
                    segment[ i ].prev_seg = segment[i-1];
                    segment[i-1].next_seg = segment[ i ];*/
                    
                    //arm_width -= arm_width*.08;
                }
                
                for( var i = 0; i &lt; seg_amount; i++) {
                    segment[i].len = seg_len;
                }
            }
        }
        
    } else if(instance_exists(target_item)) {
    
        if(arm_extent == 1) { // Can't reach item, switch item target
            var insn = instance_number(target_item.object_index);
            for(var i = 0; i &lt; insn; i++) {
                var iitem = instance_find(target_item.object_index, i);
                if(iitem != target_item &amp;&amp; distance_to_object(iitem) &lt; arm_length-tmo) {
                    target_item = iitem;
                    break;
                }
            }
        }
        
        
        
        target.x += clamp((target_item.x - target.x)*spd, -max_spd, max_spd);
        target.y += clamp((target_item.y - target.y)*spd, -max_spd, max_spd);
        
    } else {
        if(instance_exists(obj_item)) {
            var insn = instance_number(obj_item);
            seg_end = segment[seg_amount-1];
            var esbx = x;
            var esby = y;
            
            target_item = obj_item;
            for(var i = 0; i &lt; insn; i++) {
                var iitem = instance_find(obj_item, i);
                
                if( iitem != target_item &amp;&amp; 
                    point_distance(esbx, esby, iitem.x, iitem.y) &lt; 
                    point_distance(esbx, esby, target_item.x, target_item.y)) {
                        target_item = iitem;
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>randomize();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
draw_set_color(c_white);
for(var i = seg_amount-1; i &gt;= 0; i--) {
    with(segment[i]) {
        if(instance_exists(next_seg)) {
            seg_follow(next_seg.x, next_seg.y);
        } else seg_follow(parent.target.x, parent.target.y);
        
        seg_update();
    }
}

segment[0].x = x;
segment[0].y = y;
with(segment[0]) seg_calcb(len, angle);

for(var i = 0; i &lt; seg_amount; i++) {

    with(segment[i]) {
        if(instance_exists(prev_seg)) {
            x = prev_seg.bx;
            y = prev_seg.by;
            seg_calcb(len, angle);
        }
    }
    
    //draw_set_color(make_colour_hsv(i*(255/seg_amount), 255, 250));
    draw_line(segment[i].x,segment[i].y,segment[i].bx,segment[i].by);
    //draw_set_color(c_white);
    draw_circle(segment[i].x, segment[i].y, arm_width/2, true);
    
    
}
draw_circle(seg_end.bx, seg_end.by, arm_width/2, true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
